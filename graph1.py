# -*- coding: utf-8 -*-
"""graph1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15JoJ0grf5a-rjuJ4SfD34DgwspxFcZJz
"""

import time
import random
import matplotlib.pyplot as plt

# Function to generate a sorted random array
def generate_sorted_array(n):
    arr = [random.randint(0, 1000) for _ in range(n)]
    arr.sort()
    return arr

# Binary Search function
def binary_search(arr, low, high, value):
    if low > high:
        return -1
    mid = (low + high) // 2
    if arr[mid] == value:
        return mid
    elif arr[mid] > value:
        return binary_search(arr, low, mid - 1, value)
    else:
        return binary_search(arr, mid + 1, high, value)

# Function to measure execution time of binary search
def measure_time(n):
    arr = generate_sorted_array(n)
    value = random.randint(0, 1000)  # Random value to search
    start_time = time.time()
    binary_search(arr, 0, len(arr) - 1, value)
    end_time = time.time()
    return end_time - start_time

# Array sizes (n) for testing
array_sizes = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]
execution_times = []

# Measure time for each array size
for size in array_sizes:
    exec_time = measure_time(size)
    execution_times.append(exec_time)

# Plotting the graph
plt.plot(array_sizes, execution_times, marker='o')
plt.xlabel('Array Size (n)')
plt.ylabel('Execution Time (seconds)')
plt.title('Binary Search Execution Time vs Array Size')
plt.grid(True)
plt.show()